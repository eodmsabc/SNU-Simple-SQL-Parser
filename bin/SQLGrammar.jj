options
{
  static = true;
  DEBUG_PARSER = false;
  IGNORE_CASE = true;
}

PARSER_BEGIN(SQLParser)
// importimport java.io.*;
import java.util.ArrayList;
import com.sleepycat.je.Database;
import com.sleepycat.je.DatabaseException;
import com.sleepycat.je.DatabaseConfig;
import com.sleepycat.je.DatabaseEntry;
import com.sleepycat.je.Cursor;
import com.sleepycat.je.LockMode;
import com.sleepycat.je.OperationStatus;
import com.sleepycat.je.Environment;
import com.sleepycat.je.EnvironmentConfig;
import SQL.*;

public class SQLParser
{
  /* Constant Definition */
  public static final String PROMPT 				= "DB_2014-15395> ";

  public static final String DB_TABLE_LIST 		= "--DBTableList";

  static Environment myDbEnvironment = null;

  static Database myDatabase = null;

  public static void main(String args []) throws ParseException
  {
    db_init();
    SQLParser parser = new SQLParser(System.in);
    System.out.print(PROMPT);
    while (true) {
      try {
        parser.command();
      }
      catch (Exception e) {
        printMessage(new DBMessage(MsgType.SyntaxError));
        SQLParser.ReInit(System.in);
      }
    }
  }

  public static void printMessage(DBMessage q)
  {
    if (q == null) {
      System.out.print(PROMPT);
      return;
    }
    
    /* Print appropriate message by q */
    switch (q.type)
    {
      case SyntaxError : 
        System.out.println("Syntax error");
        break;
      case NotImplemented : 
        System.out.println("Not Implemented");
        break;
      
      // Create Table      case CreateTableSuccess : 
        System.out.println("\'" + q.identifier + "\' table is created");
        break;
      case DuplicateColumnDefError : 
        System.out.println("Create table has failed: column definition is duplicated");
        break;
      case DuplicatePrimaryKeyDefError : 
        System.out.println("Create table has failed: primary key definition is duplicated");
        break;
      case ReferenceTypeError : 
        System.out.println("Create table has failed: foreign key references wrong type");
        break;
      case ReferenceNonPrimaryKeyError : 
        System.out.println("Create table has failed: foreign key references non primary key column");
        break;
      case ReferenceColumnExistenceError : 
        System.out.println("Create table has failed: foreign key references non existing column");
        break;
      case ReferenceTableExistenceError : 
        System.out.println("Create table has failed: foreign key references non existing table");
        break;
      case NonExistingColumnDefError : 
        System.out.println("Create table has failed: \'" + q.identifier + "\' does not exists in column definition");
        break;
      case TableExistenceError : 
        System.out.println("Create table has failed: table with the same name already exists");
        break;
      case CharLengthError : 
        System.out.println("Char length should be over 0");
        break;
        
      // Drop Table      case DropSuccess : 
        System.out.println("\'" + q.identifier + "\' table is dropped");
        break;
      case DropReferencedTableError : 
        System.out.println("Drop table has failed: \'" + q.identifier + "\' is referenced by other table");
        break;
      case NoSuchTable : 
        System.out.println("No such table");
        break;
        
      // Show Tables      case ShowTablesNoTable : 
        System.out.println("There is no table");
        break;
      
      // Insert      case InsertResult : 
        System.out.println("The row is inserted");
        break;
      case InsertDuplicatePrimaryKeyError : 
        System.out.println("Insertion has failed: Primary key duplication");
        break;
      case InsertReferentialIntegrityError : 
        System.out.println("Insertion has failed: Referential integrity violation");
        break;
      case InsertTypeMismatchError : 
        System.out.println("Insertion has failed: Types are not matched");
        break;
      case InsertColumnExistenceError : 
        System.out.println("Insertion has failed: '" + q.identifier + "' does not exist");
        break;
      case InsertColumnNonNullableError : 
        System.out.println("Insertion has failed: '" + q.identifier + "' is not nullable");
        break;
      
      // Delete      case DeleteResult : 
        System.out.println(q.count + " row(s) are deleted");
        break;
      case DeleteReferentialIntegrityPassed : 
        System.out.println(q.count + " row(s) are not deleted due to referential integrity");
        break;
      
      // Select      case SelectTableExistenceError : 
        System.out.println("Selection has failed: '" + q.identifier + "' does not exist");
        break;
      case SelectColumnResolveError : 
        System.out.println("Selection has failed: fail to resolve '" + q.identifier + "'");
        break;
      // Where      case WhereIncomparableError : 
        System.out.println("Where clause try to compare incomparable values");
        break;
      case WhereTableNotSpecified : 
        System.out.println("Where clause try to reference tables which are not specified");
        break;
      case WhereColumnNotExist : 
        System.out.println("Where clause try to reference non existing column");
        break;
      case WhereAmbiguousReference : 
        System.out.println("Where clause contains ambiguous reference");
        break;
    }
    System.out.print(PROMPT);
  }

  // Initialize Database  public static void db_init()
  {
    EnvironmentConfig envConfig = new EnvironmentConfig();
    envConfig.setAllowCreate(true);
    myDbEnvironment = new Environment(new File("db/"), envConfig);
    DatabaseConfig dbConfig = new DatabaseConfig();
    dbConfig.setAllowCreate(true);
    dbConfig.setSortedDuplicates(false);
    myDatabase = myDbEnvironment.openDatabase(null, "myDatabase", dbConfig);
    
    byte [] data = db_byte_search(DB_TABLE_LIST);
    
    if (data == null) {
      // Create new db table list      ArrayList <String> newTableList = new ArrayList <String> ();
      db_byte_insert(DB_TABLE_LIST, db_objSerialize(newTableList));
    }
  }

  // Close Database  public static void db_close() {
    if (myDatabase != null) myDatabase.close();
    if (myDbEnvironment != null) myDbEnvironment.close();
  }

  // Serialize object  private static < T extends Serializable > byte [] db_objSerialize(T obj)
  {
    byte [] data = null;
    ByteArrayOutputStream byteOut;
    ObjectOutputStream objOut;
    
    try {
      byteOut = new ByteArrayOutputStream();
      objOut = new ObjectOutputStream(byteOut);
      
      objOut.writeObject(obj);
      data = byteOut.toByteArray();
      
      byteOut.close();
      objOut.close();
    }
    catch (Exception e) {
      e.printStackTrace();
    }
    return data;
  }

  // Deserialize object  private static Object db_objDeserialize(byte [] data)
  {
    Object retobj = null;
    if (data != null) {
      ByteArrayInputStream byteIn;
      ObjectInputStream objIn;
      
      try {
        byteIn = new ByteArrayInputStream(data);
        objIn = new ObjectInputStream(byteIn);
        
        retobj = objIn.readObject();
        
        byteIn.close();
        objIn.close();
      }
      catch (Exception e) {
        e.printStackTrace();
      }
    }
    return retobj;
  }

  // Query process for create table  public static DBMessage query_createTable(String table, ArrayList < Parse_TableElement > elements)
  {
    // Check if there already exists a table with same name    if (db_checkTableExist(table)) {      return new DBMessage(MsgType.TableExistenceError);
    }
    
    ArrayList < Parse_TableElement > colDefs = new ArrayList < Parse_TableElement > ();
    ArrayList < String > pKeyConstraints = null;
    ArrayList < Parse_TableElement > fKeyConstraints = new ArrayList < Parse_TableElement > ();
    
    boolean pKeyAppeared = false;
    
    for (Parse_TableElement elem : elements)
    {
      switch (elem.type)
      {
        case COLDEF: 
          colDefs.add(elem);
          break;
        
        case PRIMARY: 
          // Duplicated Primary Key Definition          if (pKeyAppeared) {
            return new DBMessage(MsgType.DuplicatePrimaryKeyDefError);
          }
          pKeyAppeared = true;
          pKeyConstraints = elem.primary;
          break;
        
        case FOREIGN: 
          fKeyConstraints.add(elem);
          break;
      }
    }
    
    Relation relation = new Relation(table);
    DBMessage msg = null;
    msg = relation.createSchema(colDefs, pKeyConstraints);
    
    if (msg != null) {
      return msg;
    }
    
    // Foreign Key Constraints
    Relation foreignRelation;    for (Parse_TableElement elem : fKeyConstraints)
    {
      foreignRelation = db_getRelation(elem.refTable);
      
      if (foreignRelation == null) {
        return new DBMessage(MsgType.ReferenceTableExistenceError);
      }

      // Check the count of reference column
      int forKeySize = elem.foreign.size();
      int refKeySize = elem.refKeys.size();
      if (forKeySize != refKeySize) {
        return new DBMessage(MsgType.ReferenceTypeError);
      }
      
      msg = Relation.referenceCheck(relation, foreignRelation, elem);
      
      if (msg != null) {
        return msg;
      }     }        ArrayList<String> foreignKeys = relation.getForeignKeys();
    for (String fKey : foreignKeys)
    {
      String refTable = relation.getRefTable(fKey);
      db_addReferenceList(refTable, table);
    }
    
    db_insertTableList(table);
    db_createTable(table, relation);
    return new DBMessage(MsgType.CreateTableSuccess, table);
  }

  // Query process for drop table  public static DBMessage query_dropTable(String table)
  {
    Relation relation = db_getRelation(table);
    
    // Search if table exists    if (relation == null) {       return new DBMessage(MsgType.NoSuchTable);
    }
    
    // Check if referenced by other table    if (relation.getRefCount() > 0) {      return new DBMessage(MsgType.DropReferencedTableError, table);
    }

    ArrayList < String > foreignKeys = relation.getForeignKeys();
    for (String fKey : foreignKeys)
    {
      String refTable = relation.getRefTable(fKey);
      db_delReferenceList(refTable, table);
    }
    
    db_removeTableList(table);
    db_byte_delete(table);
    return new DBMessage(MsgType.DropSuccess, table);
  }

  // Query process for desc operation  public static DBMessage query_desc(String table)
  {
    Relation relation = db_getRelation(table);

    // Check if there is no such table    if (relation == null) {      return new DBMessage(MsgType.NoSuchTable);
    }

    System.out.println(relation.describe());
    
    return new DBMessage();
  }

  // Query process for show tables  public static DBMessage query_showTables()
  {
    ArrayList < String > tableList = (ArrayList < String >) db_objDeserialize(db_byte_search(DB_TABLE_LIST));
    // If there is no table in database    if (tableList.size() == 0)
    {
      // Error Message ShowTablesNoTable      return new DBMessage(MsgType.ShowTablesNoTable);
    }
    System.out.println("----------------");
    for (String tableName : tableList)
    {
      System.out.println(tableName);
    }
    System.out.println("----------------");
    return new DBMessage();
  }

  // Query process for insert table  public static DBMessage query_insert(String table, Parse_InsertValue insertVal)
  {
    Relation relation = db_getRelation(table);
    DBMessage msg;
    
    if (relation == null) {
      return new DBMessage(MsgType.NoSuchTable);
    }

    ArrayList<ValueCompare> vcList = new ArrayList<ValueCompare>();
    msg = relation.insertConstraintsCheck(insertVal, vcList);

    if (msg != null) {
      return msg;
    }

    ArrayList<String> referingTableList = relation.getReferingTableList();
    for (String refTableName : referingTableList) {
      ArrayList<String> refColList = relation.getTableReferingColumns(refTableName);
      ArrayList<ValueCompare> filteredVC = ValueCompare.vcColumnFilter(vcList, refColList);

      ArrayList<ArrayList<Value>> refResult = new ArrayList<ArrayList<Value>>();
      Relation refRelation = db_getRelation(refTableName);

      msg = refRelation.select(filteredVC, refResult);
      if (msg != null) {
        // TODO DEBUG This code should not be executed
        System.out.println("This should not be displayed. Insert Primary Search Error");
      }

      if (refResult.size() != 1) {
        return new DBMessage(MsgType.InsertReferentialIntegrityError);
      }
    }

    relation.insertRecord(vcList);    return new DBMessage();
  }

  // Query process for delete table  public static DBMessage query_delete(String table, Parse_InsertValue insertVal)
  {
    // TODO    return new DBMessage(MsgType.NotImplemented);
  }

  // Query process for select table  public static DBMessage query_select(String table, Parse_InsertValue insertVal)
  {
    // TODO    return new DBMessage(MsgType.NotImplemented);
  }

  // Physically insert new table in key-value pair  private static void db_createTable(String table, Relation rel)
  {
    db_byte_insert(table, db_objSerialize(rel));
  }

  // Add to table list  private static void db_insertTableList(String table)
  {
    ArrayList < String > tableList = (ArrayList < String >) db_objDeserialize(db_byte_search(DB_TABLE_LIST));
    if (tableList == null) return;
    if (tableList.contains(table)) return;
    tableList.add(table);
    db_byte_replace(DB_TABLE_LIST, db_objSerialize(tableList));
  }

  // Delete from table list  private static void db_removeTableList(String table)
  {
    ArrayList < String > tableList = (ArrayList < String >) db_objDeserialize(db_byte_search(DB_TABLE_LIST));
    if (tableList == null) return;
    if (!tableList.contains(table)) return;
    tableList.remove(table);
    db_byte_replace(DB_TABLE_LIST, db_objSerialize(tableList));
  }

  // Check if table name exists  private static boolean db_checkTableExist(String table)
  {
    ArrayList < String > tableList = (ArrayList < String >) db_objDeserialize(db_byte_search(DB_TABLE_LIST));
    return tableList.contains(table);
  }

  // Get Relation  private static Relation db_getRelation(String table)
  {
    byte [] data = db_byte_search(table);
    Relation rel = null;
    if (data != null)
    {
      rel = (Relation) db_objDeserialize(data);
    }
    return rel;
  }

  // Add to reference list  private static void db_addReferenceList(String target, String curr)
  {
    Relation targetRel = db_getRelation(target);
    if (targetRel == null) return;
    targetRel.addReferedTableList(curr);
    db_byte_replace(target, db_objSerialize(targetRel));
  }

  // Delete from reference list  private static void db_delReferenceList(String target, String curr)
  {
    Relation targetRel = db_getRelation(target);
    if (targetRel == null) return;
    targetRel.delReferedTableList(curr);
    db_byte_replace(target, db_objSerialize(targetRel));
  }

  // Insert byte data in key-value pair  private static void db_byte_insert(String key, byte [] data)
  {
    Cursor cursor = null;
    try
    {
      cursor = myDatabase.openCursor(null, null);
      DatabaseEntry db_key = new DatabaseEntry(key.getBytes("UTF-8"));
      DatabaseEntry db_data = new DatabaseEntry(data);
      cursor.put(db_key, db_data);
    }
    catch (Exception e)
    {
      e.printStackTrace();
    }
    cursor.close();
  }

  // Get byte data from key  private static byte [] db_byte_search(String key)
  {
    Cursor cursor = null;
    byte [] value = null;
    try
    {
      cursor = myDatabase.openCursor(null, null);
      DatabaseEntry db_key = new DatabaseEntry(key.getBytes("UTF-8"));
      DatabaseEntry db_value = new DatabaseEntry();
      if (cursor.getSearchKey(db_key, db_value, LockMode.DEFAULT) == OperationStatus.SUCCESS)
      {
        value = db_value.getData();
      }
    }
    catch (Exception e)
    {
      e.printStackTrace();
    }
    cursor.close();
    return value;
  }

  // Replace value with new byteData  private static void db_byte_replace(String key, byte [] newData)
  {
    Cursor cursor = null;
    try
    {
      cursor = myDatabase.openCursor(null, null);
      DatabaseEntry db_key = new DatabaseEntry(key.getBytes("UTF-8"));
      DatabaseEntry db_value = new DatabaseEntry();
      DatabaseEntry new_value;
      if (cursor.getSearchKey(db_key, db_value, LockMode.DEFAULT) == OperationStatus.SUCCESS)
      {
        new_value = new DatabaseEntry(newData);
        cursor.putCurrent(new_value);
      }
    }
    catch (Exception e)
    {
      e.printStackTrace();
    }
    cursor.close();
  }

  // Delete key-value pair  private static void db_byte_delete(String key)
  {
    Cursor cursor = null;
    try
    {
      cursor = myDatabase.openCursor(null, null);
      DatabaseEntry db_key = new DatabaseEntry(key.getBytes("UTF-8"));
      DatabaseEntry db_value = new DatabaseEntry();
      if (cursor.getSearchKey(db_key, db_value, LockMode.DEFAULT) == OperationStatus.SUCCESS)
      {
        cursor.delete();
      }
    }
    catch (Exception e)
    {
      e.printStackTrace();
    }
    cursor.close();
  }
}

PARSER_END(SQLParser)

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
} // Default Skip Token
TOKEN : /* Keywords */
{
  < EXIT : "exit" >
| < INT : "int" >
| < CHAR : "char" >
| < DATE : "date" >
| < CREATE_TABLE : "create table" >
| < PRIMARY_KEY : "primary key" >
| < FOREIGN_KEY : "foreign key" >
| < REFERENCES : "references" >
| < DROP_TABLE : "drop table" >
| < DESC : "desc" >
| < SHOW_TABLES : "show tables" >
| < SELECT : "select" >
| < AS : "as" >
| < FROM : "from" >
| < WHERE : "where" >
| < OR : "or" >
| < AND : "and" >
| < NOT : "not" >
| < IS : "is" >
| < INSERT_INTO : "insert into" >
| < VALUES : "values" >
| < NULL : "null" >
| < DELETE_FROM : "delete from" >
}

/* Change Lexical State when QUOTE appeared */
TOKEN :
{
  < QUOTE : "\'" > : IN_QUOTE
}

< IN_QUOTE >
SKIP :
{
  "\r"
| "\t"
| "\n"
}	 // Newly defined skip token
< IN_QUOTE >
TOKEN :
{
  < INQ_QUOTE : "\'" > : DEFAULT
| < INQ_SPACE : " " >
| < NON_QUOTE_SPECIAL_CHARACTERS : ~[ "\'", "\"", "0"-"9", "A"-"Z", "a"-"z" ] >
| < NON_QUOTE_CHARACTER :
    < DIGIT >
  | < ALPHABET >
  | < NON_QUOTE_SPECIAL_CHARACTERS >
  | < INQ_SPACE > >
}

TOKEN : /* Tokens */
{
  < SEMICOLON : ";" >
| < LEFT_PAREN : "(" >
| < RIGHT_PAREN : ")" >
| < COMMA : "," >
| < UNDERSCORE : "_" >
| < INT_VALUE : (< SIGN >)? (< DIGIT >)+ >
| < SIGN :
    "+"
  | "-" >
| < DIGIT : [ "0"-"9" ] >
| < LEGAL_IDENTIFIER :
    < ALPHABET >
    (
      < ALPHABET >
    | < UNDERSCORE >
    )* >
| < ALPHABET : [ "a"-"z", "A"-"Z" ] >
| < ASTERISK : "*" >
| < PERIOD : "." >
| < COMP_OP :
    "<"
  | ">"
  | "="
  | ">="
  | "<="
  | "!=" >
| < CHAR_STRING : < QUOTE > (< NON_QUOTE_CHARACTER >)* < QUOTE > >
| < NNNN : < DIGIT > < DIGIT > < DIGIT > < DIGIT > >
| < NN : < DIGIT > < DIGIT > >
| < DATE_VALUE : < NNNN > "-" < NN > "-" < NN > >
}

/* Parse Command */
void command() :
{}
{
  queryList()
|
  (
    < EXIT > 
    < SEMICOLON >
    {
      db_close();
      System.exit(0);
    }
  )
}

void queryList() :
{
  DBMessage msg;
}
{
  (
    msg = query()
    {
      printMessage(msg);
    }
  )+
}

DBMessage query() :
{
  DBMessage msg;
}
{
  (
    msg = createTableQuery()
  | msg = dropTableQuery()
  | msg = descQuery()
  | msg = selectQuery()
  | msg = insertQuery()
  | msg = deleteQuery()
  | msg = showTablesQuery()
  )
  {
    return msg;
  }
}

/* CREATE TABLE QUREY */
DBMessage createTableQuery() :
{
  DBMessage msg;
  String table;
  ArrayList < Parse_TableElement > schema;
}
{
  < CREATE_TABLE > 
  table = tableName() 
  schema = tableElementList() 
  < SEMICOLON >
  {
    msg = query_createTable(table, schema);
    return msg;
  }
}

ArrayList < Parse_TableElement > tableElementList() :
{
  ArrayList < Parse_TableElement > tableElementList = new ArrayList < Parse_TableElement > ();
  Parse_TableElement element;
}
{
  < LEFT_PAREN > 
  element = tableElement()
  {
    tableElementList.add(element);
  }
  (
    < COMMA > 
    element = tableElement()
    {
      tableElementList.add(element);
    }
  )*
  < RIGHT_PAREN >
  {
    return tableElementList;
  }
}

Parse_TableElement tableElement() :
{
  Parse_TableElement elem;
}
{
  (
    elem = columnDefinition()
  | elem = tableConstraintDefinition()
  )
  {
    return elem;
  }
}

Parse_TableElement columnDefinition() :
{
  Parse_TableElement elem;
  String colName;
  boolean nullable = true;
}
{
  colName = columnName() 
  elem = dataType() 
  (
  < NOT > 
  < NULL >
  {
    nullable = false;
  }
  )?
  {
    elem.columnName = colName;
    elem.nullable = nullable;
    return elem;
  }
}

Parse_TableElement tableConstraintDefinition() :
{
  Parse_TableElement elem;
}
{
  (
    elem = primaryKeyConstraint()
  | elem = referentialConstraint()
  )
  {
    return elem;
  }
}

Parse_TableElement primaryKeyConstraint() :
{
  ArrayList < String > colList;
}
{
  < PRIMARY_KEY > 
  colList = columnNameList()
  {
    return new Parse_TableElement(colList);
  }
}

Parse_TableElement referentialConstraint() :
{
  String table;
  ArrayList < String > foreignColList;
  ArrayList < String > refColList;
}
{
  < FOREIGN_KEY > 
  foreignColList = columnNameList() 
  < REFERENCES > 
  table = tableName() 
  refColList = columnNameList()
  {
    return new Parse_TableElement(foreignColList, table, refColList);
  }
}

ArrayList < String > columnNameList() :
{
  ArrayList < String > colList = new ArrayList < String > ();
  String elem;
}
{
  < LEFT_PAREN > 
  elem = columnName()
  {
    colList.add(elem);
  }
  (
    < COMMA > 
    elem = columnName()
    {
      colList.add(elem);
    }
  )*
  < RIGHT_PAREN >
  {
    return colList;
  }
}

Parse_TableElement dataType() :
{
  Token intval;
}
{
  < INT >
  {
    return new Parse_TableElement(DataType.TYPE_INT);
  }
|
  (
    < CHAR > 
    < LEFT_PAREN > 
    intval = < INT_VALUE > 
    < RIGHT_PAREN >
    {
      return new Parse_TableElement(DataType.TYPE_CHAR, Integer.parseInt(intval.image));
    }
  )
| < DATE >
  {
    return new Parse_TableElement(DataType.TYPE_DATE);
  }
}

String tableName() :
{
  Token id;
}
{
  id = < LEGAL_IDENTIFIER >
  {
    return id.image.toLowerCase();
  }
}

String columnName() :
{
  Token id;
}
{
  id = < LEGAL_IDENTIFIER >
  {
    return id.image.toLowerCase();
  }
}

/* DROP TABLE QUERY */
DBMessage dropTableQuery() :
{
  DBMessage msg;
  String table;
}
{
  < DROP_TABLE > 
  table = tableName() 
  < SEMICOLON >
  {
    msg = query_dropTable(table);
    return msg;
  }
}

/* DESC QUERY */
DBMessage descQuery() :
{
  DBMessage msg;
  String table;
}
{
  < DESC > 
  table = tableName() 
  < SEMICOLON >
  {
    msg = query_desc(table);
    return msg;
  }
}

/* SHOW TABLES QUERY */
DBMessage showTablesQuery() :
{
  DBMessage msg;
}
{
  < SHOW_TABLES > 
  < SEMICOLON >
  {
    msg = query_showTables();
    return msg;
  }
}

/* SELECT QUERY */
DBMessage selectQuery() :
{}
{
  < SELECT > 
  selectList() 
  tableExpression() 
  < SEMICOLON >
  {
    return new DBMessage(MsgType.NotImplemented);
  }
}

void selectList() :
{}
{
  < ASTERISK >
|
  (
    selectedColumn()
    (
      < COMMA > 
      selectedColumn()
    )*
  )
}

void selectedColumn() :
{}
{
  (
    /*   * LOOKAHEAD : Warning Suppression : Choice Conflict   *   * Parser should check 2 token before entering '?' statement   * because both tableName() and columnName() are < LEGAL_IDENTIFIER >   */
    LOOKAHEAD(tableName() < PERIOD >)
    tableName() 
    < PERIOD >
  )?
  columnName()
  (
    < AS > 
    columnName()
  )?
}

void tableExpression() :
{}
{
  fromClause()
  (
    whereClause()
  )?
}

void fromClause() :
{}
{
  < FROM > 
  tableReferenceList()
}

void tableReferenceList() :
{}
{
  referedTable()
  (
    < COMMA > 
    referedTable()
  )*
}

void referedTable() :
{}
{
  tableName()
  (
    < AS > 
    tableName()
  )?
}

void whereClause() :
{}
{
  < WHERE > 
  booleanValueExpression()
}

void booleanValueExpression() :
{}
{
  booleanTerm()
  (
    < OR > 
    booleanTerm()
  )*
}

void booleanTerm() :
{}
{
  booleanFactor()
  (
    < AND > 
    booleanFactor()
  )*
}

void booleanFactor() :
{}
{
  (
  < NOT >
  )? 
  booleanTest()
}

void booleanTest() :
{}
{
  predicate()
| parenthesizedBooleanExpression()
}

void parenthesizedBooleanExpression() :
{}
{
  < LEFT_PAREN > 
  booleanValueExpression() 
  < RIGHT_PAREN >
}

void predicate() :
{}
{
  /* * LOOKAHEAD : Warning Suppression : Conflict involving two expansions * * Parser should check compOperand() and < COMP_OP > * because both comparisonPredicate() and nullPredicate() can be start with < LEGAL_IDENTIFIER > */
  LOOKAHEAD(compOperand() < COMP_OP >)
  comparisonPredicate()
| nullPredicate()
}

void comparisonPredicate() :
{}
{
  compOperand() 
  < COMP_OP > 
  compOperand()
}

void compOperand() :
{}
{
  comparableValue()
|
  (
    (
      /*     * LOOKAHEAD : Warning Suppression : Choice Conflict     *     * Parser should check 2 token before entering '?' statement     * because both tableName() and columnName() are < LEGAL_IDENTIFIER >     */
      LOOKAHEAD(tableName() < PERIOD >)
      tableName() 
      < PERIOD >
    )?
    columnName()
  )
}

Value comparableValue() :
{
  Token id;
}
{
  id = < INT_VALUE >
  { return new Value(Integer.parseInt(id.image)); }
| id = < CHAR_STRING >
  { return new Value(id.image); }
| id = < DATE_VALUE >
  { return new Value(new Date(id.image)); }
}

void nullPredicate() :
{}
{
  (
    (
      /*     * LOOKAHEAD : Warning Suppression : Choice Conflict     *     * Parser should check 2 token before entering '?' statement     * because both tableName() and columnName() are < LEGAL_IDENTIFIER >     */
      LOOKAHEAD(tableName() < PERIOD >)
      tableName() 
      < PERIOD >
    )?
    columnName() 
    nullOperation()
  )
}

void nullOperation() :
{}
{
  < IS > 
  (< NOT >)? 
  < NULL >
}

/* INSERT QUERY */
DBMessage insertQuery() :
{
  DBMessage msg;
  String table;
  Parse_InsertValue insertVal;
}
{
  < INSERT_INTO > 
  table = tableName() 
  insertVal = insertColumnsAndSource() 
  < SEMICOLON >
  {
    msg = query_insert(table, insertVal);
    return msg;
  }
}

Parse_InsertValue insertColumnsAndSource() :
{
  ArrayList < String > colList = null;
  ArrayList < Value > valList = null;
}
{
  (
    colList = columnNameList()
  )?
  valList = valueList()
  {
    return new Parse_InsertValue(colList, valList);
  }
}

ArrayList < Value > valueList() :
{
  ArrayList < Value > valList = new ArrayList<Value>();
  Value val;
}
{
  < VALUES > 
  < LEFT_PAREN > 
  val = value()
  {
    if (val == null) {
      valList.add(new Value());
    }
    else {
      valList.add(val);
    }
  }    
  (
    < COMMA > 
    val = value()
    {
      if (val == null) {
        valList.add(new Value());
      }
      else {
        valList.add(val);
      }
    }
  )*
  < RIGHT_PAREN >
  { return valList; }
}

Value value() :
{
  Value val;
}
{
  < NULL >
  { return null; }
| val = comparableValue()
  { return val; }
}

/* DELETE QUERY */
DBMessage deleteQuery() :
{}
{
  < DELETE_FROM > 
  tableName()
  (
    whereClause()
  )?
  < SEMICOLON >
  {
    return new DBMessage(MsgType.NotImplemented);
  }
}

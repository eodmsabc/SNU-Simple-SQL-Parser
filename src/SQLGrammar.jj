options{  static = true;  DEBUG_PARSER = false;  IGNORE_CASE = true;}PARSER_BEGIN(SQLParser)// importimport java.io.*;import java.util.ArrayList;import com.sleepycat.je.Database;import com.sleepycat.je.DatabaseException;import com.sleepycat.je.DatabaseConfig;import com.sleepycat.je.DatabaseEntry;import com.sleepycat.je.Cursor;import com.sleepycat.je.LockMode;import com.sleepycat.je.OperationStatus;import com.sleepycat.je.Environment;import com.sleepycat.je.EnvironmentConfig;import SQL.*;public class SQLParser{  /* Constant Definition */  public static final String PROMPT				= "DB_2014-15395> ";    public static final String DB_TABLE_LIST		= "--DBTableList";  static Environment myDbEnvironment = null;  static Database myDatabase = null;    public static void main(String args[]) throws ParseException  {    db_init();        SQLParser parser = new SQLParser(System.in);    System.out.print(PROMPT);    while (true)    {      try      {        parser.command();      }      catch (Exception e)      {        printMessage(new DBMessage(MsgType.SyntaxError));        SQLParser.ReInit(System.in);      }    }  }  public static void printMessage(DBMessage q)
  {    if (q == null) {      System.out.print(PROMPT);      return;    }
    /* Print appropriate message by q */
    switch (q.type)
    {
      case SyntaxError: 
        System.out.println("Syntax error");
        break;      case NotImplemented:        System.out.println("Not Implemented");        break;      // Create Table      case CreateTableSuccess:        System.out.println("\'" + q.identifier + "\' table is created");        break;      case DuplicateColumnDefError:        System.out.println("Create table has failed: column definition is duplicated");        break;      case DuplicatePrimaryKeyDefError:        System.out.println("Create table has failed: primary key definition is duplicated");        break;      case ReferenceTypeError:        System.out.println("Create table has failed: foreign key references wrong type");        break;      case ReferenceNonPrimaryKeyError:        System.out.println("Create table has failed: foreign key references non primary key column");        break;      case ReferenceColumnExistenceError:        System.out.println("Create table has failed: foreign key references non existing column");        break;      case ReferenceTableExistenceError:        System.out.println("Create table has failed: foreign key references non existing table");        break;      case NonExistingColumnDefError:        System.out.println("Create table has failed: \'" + q.identifier + "\' does not exists in column definition");        break;      case TableExistenceError:        System.out.println("Create table has failed: table with the same name already exists");        break;      case CharLengthError:        System.out.println("Char length should be over 0");        break;      // Drop Table      case DropSuccess:        System.out.println("\'" + q.identifier + "\' table is dropped");        break;      case DropReferencedTableError:        System.out.println("Drop table has failed: \'" + q.identifier + "\' is referenced by other table");        break;      case NoSuchTable:        System.out.println("No such table");        break;              // Show Tables      case ShowTablesNoTable:        System.out.println("There is no table");        break;      // Insert      case InsertResult:      	System.out.println("The row is inserted");        break;      case InsertDuplicatePrimaryKeyError:        System.out.println("Insertion has failed: Primary key duplication");        break;      case InsertReferentialIntegrityError:        System.out.println("Insertion has failed: Referential integrity violation");        break;      case InsertTypeMismatchError:        System.out.println("Insertion has failed: Types are not matched");        break;      case InsertColumnExistenceError:        System.out.println("Insertion has failed: '" + q.identifier + "' does not exist");        break;      case InsertColumnNonNullableError:        System.out.println("Insertion has failed: '" + q.identifier + "' is not nullable");        break;      // Delete      case DeleteResult:        System.out.println(q.count + " row(s) are deleted");        break;      case DeleteReferentialIntegrityPassed:        System.out.println(q.count + " row(s) are not deleted due to referential integrity");        break;      // Select      case SelectTableExistenceError:        System.out.println("Selection has failed: '" + q.identifier + "' does not exist");        break;      case SelectColumnResolveError:        System.out.println("Selection has failed: fail to resolve '" + q.identifier + "'");        break;      // Where      case WhereIncomparableError:        System.out.println("Where clause try to compare incomparable values");        break;      case WhereTableNotSpecified:        System.out.println("Where clause try to reference tables which are not specified");        break;      case WhereColumnNotExist:        System.out.println("Where clause try to reference non existing column");        break;      case WhereAmbiguousReference:        System.out.println("Where clause contains ambiguous reference");        break;
    }
    System.out.print(PROMPT);
  }  // Initialize Database  public static void db_init()  {    EnvironmentConfig envConfig = new EnvironmentConfig();    envConfig.setAllowCreate(true);    myDbEnvironment = new Environment(new File("db/"), envConfig);    DatabaseConfig dbConfig = new DatabaseConfig();    dbConfig.setAllowCreate(true);    dbConfig.setSortedDuplicates(false);    myDatabase = myDbEnvironment.openDatabase(null, "myDatabase", dbConfig);    byte[] data = db_byte_search(DB_TABLE_LIST);        if (data == null) {      // Create new db table list      ArrayList<String> newTableList = new ArrayList<String>();      db_byte_insert(DB_TABLE_LIST, db_objSerialize(newTableList));    }  }  // Close Database  public static void db_close()  {    if (myDatabase != null) myDatabase.close();    if (myDbEnvironment != null) myDbEnvironment.close();  }  // Serialize object  private static <T extends Serializable> byte[] db_objSerialize(T obj)  {    byte[] data = null;    ByteArrayOutputStream byteOut;    ObjectOutputStream objOut;    try {       byteOut = new ByteArrayOutputStream();       objOut = new ObjectOutputStream(byteOut);       objOut.writeObject(obj);       data = byteOut.toByteArray();       byteOut.close();       objOut.close();    }    catch (Exception e) {      e.printStackTrace();    }    return data;  }  // Deserialize object  private static Object db_objDeserialize(byte[] data)  {    Object retobj = null;    if (data != null) {      ByteArrayInputStream byteIn;      ObjectInputStream objIn;      try {        byteIn = new ByteArrayInputStream(data);        objIn = new ObjectInputStream(byteIn);        retobj = objIn.readObject();        byteIn.close();        objIn.close();      }      catch (Exception e) {        e.printStackTrace();      }    }    return retobj;  }    // Query process for create table  public static DBMessage query_createTable(String table, ArrayList<Parse_TableElement> elements)  {    ArrayList<DB_Attribute> schema = new ArrayList<DB_Attribute>();    boolean pKeyAppeared = false;    // Check if there already exists a table with same name    if (db_checkTableExist(table)) {      // Error Message TableExistenceError      return new DBMessage(MsgType.TableExistenceError);    }    // Column Definition    for (Parse_TableElement elem : elements)    {      DB_Attribute newelem;      if (elem.type == Parse_TableElement.ETYPE.COLDEF) {        if (elem.dataType == DataType.TYPE_CHAR) {          if (elem.charlen <= 0) {            // Error Message CharLengthError            return new DBMessage(MsgType.CharLengthError);          }          newelem = new DB_Attribute(elem.columnName, elem.dataType, elem.charlen, elem.nullable);        }        else {          newelem = new DB_Attribute(elem.columnName, elem.dataType, elem.nullable);        }        // Existence Check        if (db_findAttributeFromSchema(newelem.name, schema) != null) {          // Error Message DuplicateColumnDefError          return new DBMessage(MsgType.DuplicateColumnDefError);        }        schema.add(newelem);      }    }    // Constraints    for (Parse_TableElement elem : elements)    {       // Primary Key Constraint      if (elem.type == Parse_TableElement.ETYPE.PRIMARY) {        if (pKeyAppeared) {          // Error Message DuplicatePrimaryKeyDefError          return new DBMessage(MsgType.DuplicatePrimaryKeyDefError);        }        else {          pKeyAppeared = true;          for (String col : elem.primary)          {            boolean colFound = false;            for (DB_Attribute attr : schema)            {              if (col.equals(attr.name)) {                attr.nullable = false;                attr.primary = true;                colFound = true;                break;              }            }            if (colFound == false) {              // Error Message NonExistingColumnDefError              return new DBMessage(MsgType.NonExistingColumnDefError, col);            }          }        }      }            // Foreign Key Constraint      else if (elem.type == Parse_TableElement.ETYPE.FOREIGN) {        ArrayList<DB_Attribute> refSchema = db_schema_search(elem.refTable);                if (refSchema == null) {          // Error Message ReferenceTableExistenceError          return new DBMessage(MsgType.ReferenceTableExistenceError);        }        
        // Check the count of reference column        int forKeySize = elem.foreign.size();
        int refKeySize = elem.refKey.size();        if (forKeySize != refKeySize) {
          // Error Message ReferenceTypeError          return new DBMessage(MsgType.ReferenceTypeError);
        }        
        // Check referencing non-existing column        for (int index = 0; index < refKeySize; index++)
        {          String curCol = elem.foreign.get(index);
          String refCol = elem.refKey.get(index);                    DB_Attribute curAttr = db_findAttributeFromSchema(curCol, schema);          if (curAttr == null) {            // Error Message NonExistingColumnDefError            return new DBMessage(MsgType.NonExistingColumnDefError, curCol);          }          DB_Attribute refAttr = db_findAttributeFromSchema(refCol, refSchema);          if (refAttr == null) {            // Error Message ReferenceColumnExistenceError            return new DBMessage(MsgType.ReferenceColumnExistenceError);          }
          if (!refAttr.primary) {            // Error Message ReferenceNonPrimaryKeyError            return new DBMessage(MsgType.ReferenceNonPrimaryKeyError);          }          if (!curAttr.checkTypeMatch(refAttr)) {            // Error Message ReferenceTypeError            return new DBMessage(MsgType.ReferenceTypeError);          }          curAttr.foreign = true;          curAttr.refTable = elem.refTable;          curAttr.refAttribute = refCol;
        }                // Check if FK references all composite primary key set        for (DB_Attribute attr : refSchema)
        {
          if (attr.primary) {
            if (!elem.refKey.contains(attr.name)) {
              // Error Message ReferenceNonPrimaryKeyError              return new DBMessage(MsgType.ReferenceNonPrimaryKeyError);
            }
          }
        } // for // referencing all primary column              }// else // foreign key constraints    }// for // parse table elements    // Add references    for (DB_Attribute attr : schema) {      if (attr.foreign) {        db_addReferenceList(attr.refTable, table);      }    }    db_insertTableList(table);    db_createTable(table, schema);    db_createReference(table);    return new DBMessage(MsgType.CreateTableSuccess, table);  }  // Query process for drop table  public static DBMessage query_dropTable(String table)  {    // Search if table exists    if (!db_checkTableExist(table)) {      // Error Message NoSuchTable      return new DBMessage(MsgType.NoSuchTable);    }        // Check if referenced by other table    if (db_getRefCount(table) > 0) {      // Error Message DropReferencedTableError      return new DBMessage(MsgType.DropReferencedTableError, table);    }    ArrayList<DB_Attribute> schema = db_schema_search(table);    for (DB_Attribute attr : schema)    {      if (attr.foreign) {        db_delReferenceList(attr.refTable, table);      }    }    db_removeTableList(table);    db_byte_delete(dbRefListName(table));    db_byte_delete(dbSchemaName(table));        return new DBMessage(MsgType.DropSuccess, table);  }  // Query process for desc operation  public static DBMessage query_desc(String table)  {    ArrayList<DB_Attribute> schema = db_schema_search(table);    // Check if there is no such table    if (schema == null) {      // Error Message NoSuchTable      return new DBMessage(MsgType.NoSuchTable);    }    System.out.println("table_name [" + table + "]");    System.out.println("-------------------------------------------------");    System.out.printf(DB_Attribute.SCHEMA_FORMAT, "column_name", "type", "null", "key");    System.out.println();    for (DB_Attribute attr : schema)    {      System.out.println(attr);    }    System.out.println("-------------------------------------------------");    return new DBMessage();  }  // Query process for show tables  public static DBMessage query_showTables()  {    ArrayList<String> tableList = (ArrayList<String>) db_objDeserialize(db_byte_search(DB_TABLE_LIST));    // If there is no table in database    if (tableList.size() == 0) {      // Error Message ShowTablesNoTable      return new DBMessage(MsgType.ShowTablesNoTable);    }    System.out.println("----------------");    for (String tableName : tableList)    {      System.out.println(tableName);    }    System.out.println("----------------");    return new DBMessage();  }  // Query process for insert table  public static DBMessage query_insert(String tableName, InsertValue insertVal)  {    return new DBMessage();  }  // Physically insert new table in key-value pair  private static void db_createTable(String table, ArrayList<DB_Attribute> schema)  {    db_byte_insert(dbSchemaName(table), db_objSerialize(schema));  }  // Add to table list  private static void db_insertTableList(String table)  {    ArrayList<String> tableList = (ArrayList<String>) db_objDeserialize(db_byte_search(DB_TABLE_LIST));    if (tableList == null) return;    if (tableList.contains(table)) return;    tableList.add(table);    db_byte_replace(DB_TABLE_LIST, db_objSerialize(tableList));  }  // Delete from table list  private static void db_removeTableList(String table)  {    ArrayList<String> tableList = (ArrayList<String>) db_objDeserialize(db_byte_search(DB_TABLE_LIST));    if (tableList == null) return;    if (!tableList.contains(table)) return;    tableList.remove(table);    db_byte_replace(DB_TABLE_LIST, db_objSerialize(tableList));  }  // Check if table name exists  private static boolean db_checkTableExist(String table)  {    ArrayList<String> tableList = (ArrayList<String>) db_objDeserialize(db_byte_search(DB_TABLE_LIST));    return tableList.contains(table);  }    // Create reference list  private static void db_createReference(String table)  {    ArrayList<String> newRefList = new ArrayList<String>();    db_byte_insert(dbRefListName(table), db_objSerialize(newRefList));  }  // Get reference list  private static ArrayList<String> db_getReferenceList(String target)  {    byte[] data = db_byte_search(dbRefListName(target));    ArrayList<String> refList = null;    if (data != null) {      refList = (ArrayList<String>)db_objDeserialize(data);    }    return refList;  }  // Get reference count  private static int db_getRefCount(String table)  {    ArrayList<String> refList = db_getReferenceList(table);    if (refList == null) return -1;    return refList.size();  }  // Add to reference list  private static void db_addReferenceList(String target, String curr)  {    ArrayList<String> refList = db_getReferenceList(target);        if (refList == null) return;    if (refList.contains(curr)) return;        refList.add(curr);    db_byte_replace(dbRefListName(target), db_objSerialize(refList));  }  // Delete from reference list  private static void db_delReferenceList(String target, String curr)  {    ArrayList<String> refList = db_getReferenceList(target);        if (refList == null) return;    if (!refList.contains(curr)) return;        refList.remove(curr);    db_byte_replace(dbRefListName(target), db_objSerialize(refList));  }  // Find attribute from schema array  private static DB_Attribute db_findAttributeFromSchema(String attr, ArrayList<DB_Attribute> schema) {    for (DB_Attribute a : schema) {      if (a.name.equals(attr)) {        return a;      }    }    return null;  }  // Insert byte data in key-value pair  private static void db_byte_insert(String key, byte[] data)  {    Cursor cursor = null;    try {      cursor = myDatabase.openCursor(null, null);      DatabaseEntry db_key = new DatabaseEntry(key.getBytes("UTF-8"));      DatabaseEntry db_data = new DatabaseEntry(data);      cursor.put(db_key, db_data);    }    catch (Exception e) {      e.printStackTrace();    }    cursor.close();  }  // Get byte data from key  private static byte[] db_byte_search(String key)  {    Cursor cursor = null;    byte[] value = null;    	try {	  cursor = myDatabase.openCursor(null, null);       DatabaseEntry db_key = new DatabaseEntry(key.getBytes("UTF-8"));      DatabaseEntry db_value = new DatabaseEntry();      if (cursor.getSearchKey(db_key, db_value, LockMode.DEFAULT) == OperationStatus.SUCCESS) {        value = db_value.getData();      }          }    catch (Exception e) {      e.printStackTrace();    }    cursor.close();    return value;  }  // Search schema from key  private static ArrayList<DB_Attribute> db_schema_search(String key) {    byte[] data = db_byte_search(dbSchemaName(key));    ArrayList<DB_Attribute> schema = null;    if (data != null) {      schema = (ArrayList<DB_Attribute>) db_objDeserialize(data);    }    return schema;  }  // Replace value with new byteData  private static void db_byte_replace(String key, byte[] newData)  {    Cursor cursor = null;	try {	  cursor = myDatabase.openCursor(null, null);       DatabaseEntry db_key = new DatabaseEntry(key.getBytes("UTF-8"));      DatabaseEntry db_value = new DatabaseEntry();      DatabaseEntry new_value;            if (cursor.getSearchKey(db_key, db_value, LockMode.DEFAULT) == OperationStatus.SUCCESS) {        new_value = new DatabaseEntry(newData);         cursor.putCurrent(new_value);      }    }    catch (Exception e) {      e.printStackTrace();    }    cursor.close();  }  // Delete key-value pair  private static void db_byte_delete(String key)  {    Cursor cursor = null;	try {	  cursor = myDatabase.openCursor(null, null);       DatabaseEntry db_key = new DatabaseEntry(key.getBytes("UTF-8"));      DatabaseEntry db_value = new DatabaseEntry();            if (cursor.getSearchKey(db_key, db_value, LockMode.DEFAULT) == OperationStatus.SUCCESS) {         cursor.delete();      }          }    catch (Exception e) {      e.printStackTrace();    }    cursor.close();  }  // String Key Modification  private static String dbSchemaName(String orig) {    return "-s" + orig;  }  private static String dbRefListName(String orig) {    return "-r" + orig;  }  private static String dbDataName(String orig) {    return "-d" + orig;  }  private static String dbOrigTableName(String dbname) {    if (dbname.charAt(0) == '-') {      return dbname.substring(2);    }    else {      return dbname;    }  }
}PARSER_END(SQLParser)SKIP : { " " | "\r" | "\t" | "\n" } // Default Skip TokenTOKEN : /* Keywords */{  < EXIT : "exit" >| < INT : "int" >| < CHAR : "char" >| < DATE : "date" >| < CREATE_TABLE : "create table" >| < PRIMARY_KEY : "primary key" >| < FOREIGN_KEY : "foreign key" >| < REFERENCES : "references" >| < DROP_TABLE : "drop table" >| < DESC : "desc" >| < SHOW_TABLES : "show tables" >| < SELECT : "select" >| < AS : "as" >| < FROM : "from" >| < WHERE : "where" >| < OR : "or" >| < AND : "and" >| < NOT : "not" >| < IS : "is" >| < INSERT_INTO : "insert into" >| < VALUES : "values" >| < NULL : "null" >| < DELETE_FROM : "delete from" >}/* Change Lexical State when QUOTE appeared */TOKEN : { < QUOTE : "\'" > : IN_QUOTE }<IN_QUOTE> SKIP : { "\r" | "\t" | "\n" }	// Newly defined skip token<IN_QUOTE> TOKEN :{  < INQ_QUOTE : "\'" > : DEFAULT| < INQ_SPACE : " " >| < NON_QUOTE_SPECIAL_CHARACTERS : ~[ "\'", "\"", "0"-"9", "A"-"Z", "a"-"z" ] >| < NON_QUOTE_CHARACTER : < DIGIT > | < ALPHABET > | < NON_QUOTE_SPECIAL_CHARACTERS > | < INQ_SPACE > >}TOKEN : /* Tokens */{  < SEMICOLON : ";" >| < LEFT_PAREN : "(" >| < RIGHT_PAREN : ")" >| < COMMA : "," >| < UNDERSCORE : "_" >| < INT_VALUE : (< SIGN >)? (< DIGIT >)+ >| < SIGN : "+" | "-" >| < DIGIT : [ "0"-"9" ] >| < LEGAL_IDENTIFIER : < ALPHABET > (< ALPHABET > | < UNDERSCORE >)* >| < ALPHABET : [ "a"-"z", "A"-"Z" ] >| < ASTERISK : "*" >| < PERIOD : "." >| < COMP_OP : "<" | ">" | "=" | ">=" | "<=" | "!=" >| < CHAR_STRING : < QUOTE > (< NON_QUOTE_CHARACTER >)* < QUOTE > >| < NNNN : < DIGIT > < DIGIT > < DIGIT > < DIGIT > >| < NN : < DIGIT > < DIGIT > >| < DATE_VALUE : < NNNN > "-" < NN > "-" < NN > >}/* Parse Command */void command() :{}{  queryList()| (    < EXIT >    < SEMICOLON >    {      db_close();      System.exit(0);    }  ) }void queryList() :{ DBMessage msg; }{  (    msg = query()    {      printMessage(msg);    }  )+}DBMessage query() :{ DBMessage msg; }{  (    msg = createTableQuery()  | msg = dropTableQuery()  | msg = descQuery()  | msg = selectQuery()  | msg = insertQuery()  | msg = deleteQuery()  | msg = showTablesQuery()  )  { return msg; }}/* CREATE TABLE QUREY */DBMessage createTableQuery() :{  DBMessage msg;  String table;  ArrayList<Parse_TableElement> schema;}{  < CREATE_TABLE >  table = tableName()  schema = tableElementList()  < SEMICOLON >  {    msg = query_createTable(table, schema);    return msg;  }}ArrayList<Parse_TableElement> tableElementList() :{  ArrayList<Parse_TableElement> tableElementList = new ArrayList<Parse_TableElement>();  Parse_TableElement element;}{  < LEFT_PAREN >  element = tableElement()  { tableElementList.add(element); }  (    < COMMA >    element = tableElement()    { tableElementList.add(element); }  )*  < RIGHT_PAREN >  { return tableElementList; }}Parse_TableElement tableElement() :{ Parse_TableElement elem; }{  (    elem = columnDefinition()  | elem = tableConstraintDefinition()  )  { return elem; }}Parse_TableElement columnDefinition() :{  Parse_TableElement elem;  String colName;  boolean nullable = true;}{  colName = columnName()  elem = dataType()  (    < NOT >    < NULL >    { nullable = false; }  )?  {    elem.columnName = colName;    elem.nullable = nullable;    return elem;  }}Parse_TableElement tableConstraintDefinition() :{ Parse_TableElement elem; }{  (    elem = primaryKeyConstraint()  | elem = referentialConstraint()  )  { return elem; }}Parse_TableElement primaryKeyConstraint() :{ ArrayList<String> colList; }{  < PRIMARY_KEY >  colList = columnNameList()  { return new Parse_TableElement(colList); }}Parse_TableElement referentialConstraint() :{  String table;  ArrayList<String> foreignColList;  ArrayList<String> refColList;}{  < FOREIGN_KEY >  foreignColList = columnNameList()  < REFERENCES >  table = tableName()  refColList = columnNameList()  { return new Parse_TableElement(foreignColList, table, refColList); }}ArrayList<String> columnNameList() :{  ArrayList<String> colList = new ArrayList<String>();  String elem;}{  < LEFT_PAREN >  elem = columnName()  { colList.add(elem); }  (    < COMMA >    elem = columnName()    { colList.add(elem); }  )*  < RIGHT_PAREN >  { return colList; }}Parse_TableElement dataType() :{ Token intval; }{  < INT >  { return new Parse_TableElement(DataType.TYPE_INT); }| (    < CHAR >    < LEFT_PAREN >    intval = < INT_VALUE >    < RIGHT_PAREN >    { return new Parse_TableElement(DataType.TYPE_CHAR, Integer.parseInt(intval.image)); }  )| < DATE >  { return new Parse_TableElement(DataType.TYPE_DATE); }  }String tableName() :{ Token id; }{  id = < LEGAL_IDENTIFIER >  { return id.image.toLowerCase(); }}String columnName() :{ Token id; }{  id = < LEGAL_IDENTIFIER >  { return id.image.toLowerCase(); }}/* DROP TABLE QUERY */DBMessage dropTableQuery() :{  DBMessage msg;  String table;}{  < DROP_TABLE >  table = tableName()  < SEMICOLON >  {    msg = query_dropTable(table);    return msg;  }}/* DESC QUERY */DBMessage descQuery() :{  DBMessage msg;  String table;}{  < DESC >  table = tableName()  < SEMICOLON >  {    msg = query_desc(table);    return msg;  }}/* SHOW TABLES QUERY */DBMessage showTablesQuery() :{ DBMessage msg; }{  < SHOW_TABLES >  < SEMICOLON >  {    msg = query_showTables();    return msg;  }}/* SELECT QUERY */DBMessage selectQuery() :{}{  < SELECT >  selectList()  tableExpression()  < SEMICOLON >  { return new DBMessage(MsgType.NotImplemented); }}void selectList() :{}{  < ASTERISK >| (    selectedColumn()    (      < COMMA >  	  selectedColumn()    )*  )}void selectedColumn() :{}{  (  /*   * LOOKAHEAD : Warning Suppression : Choice Conflict   *   * Parser should check 2 token before entering '?' statement   * because both tableName() and columnName() are < LEGAL_IDENTIFIER >   */    LOOKAHEAD(tableName() < PERIOD >)    tableName()    < PERIOD >  )?  columnName()  (    < AS >    columnName()  )?}void tableExpression() :{}{  fromClause()  (    whereClause()  )?}void fromClause() :{}{  < FROM >  tableReferenceList()}void tableReferenceList() :{}{  referedTable()  (    < COMMA >    referedTable()  )*}void referedTable() :{}{  tableName()  (    < AS >    tableName()  )?}void whereClause() :{}{  < WHERE >  booleanValueExpression()}void booleanValueExpression() :{}{  booleanTerm()  (    < OR >    booleanTerm()  )*}void booleanTerm() :{}{  booleanFactor()  (    < AND >    booleanFactor()  )*}void booleanFactor() :{}{  (    < NOT >  )?  booleanTest()}void booleanTest() :{}{  predicate()| parenthesizedBooleanExpression()}void parenthesizedBooleanExpression() :{}{  < LEFT_PAREN >  booleanValueExpression()  < RIGHT_PAREN >}void predicate() :{}{/* * LOOKAHEAD : Warning Suppression : Conflict involving two expansions * * Parser should check compOperand() and < COMP_OP > * because both comparisonPredicate() and nullPredicate() can be start with < LEGAL_IDENTIFIER > */  LOOKAHEAD(compOperand() < COMP_OP >)  comparisonPredicate()| nullPredicate()}void comparisonPredicate() :{}{  compOperand()  < COMP_OP >  compOperand()}void compOperand() :{}{  comparableValue()| (    (    /*     * LOOKAHEAD : Warning Suppression : Choice Conflict     *     * Parser should check 2 token before entering '?' statement     * because both tableName() and columnName() are < LEGAL_IDENTIFIER >     */      LOOKAHEAD(tableName() < PERIOD >)      tableName()      < PERIOD >    )?    columnName()  )}void comparableValue() :{}{  < INT_VALUE >| < CHAR_STRING >| < DATE_VALUE >}void nullPredicate() :{}{  (    (    /*     * LOOKAHEAD : Warning Suppression : Choice Conflict     *     * Parser should check 2 token before entering '?' statement     * because both tableName() and columnName() are < LEGAL_IDENTIFIER >     */      LOOKAHEAD(tableName() < PERIOD >)      tableName()      < PERIOD >    )?    columnName()    nullOperation()  )}void nullOperation() :{}{  < IS >  (< NOT >)?  < NULL > }/* INSERT QUERY */DBMessage insertQuery() :{  DBMessage msg;  String table;  InsertValue insertVal;}{  < INSERT_INTO >  table = tableName()  insertVal = insertColumnsAndSource()  < SEMICOLON >  {    msg = query_insert(table, insertVal);    return msg;  }}InsertValue insertColumnsAndSource() :{  ArrayList<String> colList = null;}{  (    colList = columnNameList()  )?  valueList()  { return new InsertValue(); }}void valueList() :{}{  < VALUES >  < LEFT_PAREN >  value()  (    < COMMA >    value()  )*  < RIGHT_PAREN >}void value() :{}{  < NULL >| comparableValue()}/* DELETE QUERY */DBMessage deleteQuery() :{}{  < DELETE_FROM >  tableName()  (    whereClause()  )?  < SEMICOLON >  { return new DBMessage(MsgType.NotImplemented); }}
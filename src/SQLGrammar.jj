options
{
  static = true;
  DEBUG_PARSER = false;
  IGNORE_CASE = true;
}

PARSER_BEGIN(SQLParser)
// importimport java.io.*;
import java.util.ArrayList;
import com.sleepycat.je.Database;
import com.sleepycat.je.DatabaseException;
import com.sleepycat.je.DatabaseConfig;
import com.sleepycat.je.DatabaseEntry;
import com.sleepycat.je.Cursor;
import com.sleepycat.je.LockMode;
import com.sleepycat.je.OperationStatus;
import com.sleepycat.je.Environment;
import com.sleepycat.je.EnvironmentConfig;
import SQL.*;

public class SQLParser
{
  /* Constant Definition */
  public static final String PROMPT 				= "DB_2014-15395> ";

  public static final String DB_TABLE_LIST 		= "--DBTableList";

  static Environment myDbEnvironment = null;

  static Database myDatabase = null;

  public static void main(String args []) throws ParseException
  {
    db_init();
    SQLParser parser = new SQLParser(System.in);
    System.out.print(PROMPT);
    while (true) {
      try {
        parser.command();
      }
      catch (Exception e) {
        printMessage(new DBMessage(MsgType.SyntaxError));
        SQLParser.ReInit(System.in);
      }
    }
  }

  public static void printMessage(DBMessage q)
  {
    if (q == null) {
      System.out.print(PROMPT);
      return;
    }
    
    System.out.println(q);
    System.out.print(PROMPT);
  }

  // Initialize Database  public static void db_init()
  {
    EnvironmentConfig envConfig = new EnvironmentConfig();
    envConfig.setAllowCreate(true);
    myDbEnvironment = new Environment(new File("db/"), envConfig);
    DatabaseConfig dbConfig = new DatabaseConfig();
    dbConfig.setAllowCreate(true);
    dbConfig.setSortedDuplicates(false);
    myDatabase = myDbEnvironment.openDatabase(null, "myDatabase", dbConfig);
    
    byte [] data = db_byte_search(DB_TABLE_LIST);
    
    if (data == null) {
      // Create new db table list      ArrayList <String> newTableList = new ArrayList <String> ();
      db_byte_insert(DB_TABLE_LIST, db_objSerialize(newTableList));
    }
  }

  // Close Database  public static void db_close() {
    if (myDatabase != null) myDatabase.close();
    if (myDbEnvironment != null) myDbEnvironment.close();
  }

  // Serialize object  private static < T extends Serializable > byte [] db_objSerialize(T obj)
  {
    byte [] data = null;
    ByteArrayOutputStream byteOut;
    ObjectOutputStream objOut;
    
    try {
      byteOut = new ByteArrayOutputStream();
      objOut = new ObjectOutputStream(byteOut);
      
      objOut.writeObject(obj);
      data = byteOut.toByteArray();
      
      byteOut.close();
      objOut.close();
    }
    catch (Exception e) {
      e.printStackTrace();
    }
    return data;
  }

  // Deserialize object  private static Object db_objDeserialize(byte [] data)
  {
    Object retobj = null;
    if (data != null) {
      ByteArrayInputStream byteIn;
      ObjectInputStream objIn;
      
      try {
        byteIn = new ByteArrayInputStream(data);
        objIn = new ObjectInputStream(byteIn);
        
        retobj = objIn.readObject();
        
        byteIn.close();
        objIn.close();
      }
      catch (Exception e) {
        e.printStackTrace();
      }
    }
    return retobj;
  }

  // Query process for create table  public static DBMessage query_createTable(String table, ArrayList < Parse_TableElement > elements)
  {
    // Check if there already exists a table with same name    if (db_checkTableExist(table)) {      return new DBMessage(MsgType.TableExistenceError);
    }
    
    ArrayList < Parse_TableElement > colDefs = new ArrayList < Parse_TableElement > ();
    ArrayList < String > pKeyConstraints = null;
    ArrayList < Parse_TableElement > fKeyConstraints = new ArrayList < Parse_TableElement > ();
    
    boolean pKeyAppeared = false;
    
    for (Parse_TableElement elem : elements)
    {
      switch (elem.type)
      {
        case COLDEF: 
          colDefs.add(elem);
          break;
        
        case PRIMARY: 
          // Duplicated Primary Key Definition          if (pKeyAppeared) {
            return new DBMessage(MsgType.DuplicatePrimaryKeyDefError);
          }
          pKeyAppeared = true;
          pKeyConstraints = elem.primary;
          break;
        
        case FOREIGN: 
          fKeyConstraints.add(elem);
          break;
      }
    }
    
    Relation relation = new Relation(table);
    DBMessage msg = null;
    msg = relation.createSchema(colDefs, pKeyConstraints);
    
    if (msg != null) {
      return msg;
    }
    
    // Foreign Key Constraints
    Relation foreignRelation;    for (Parse_TableElement elem : fKeyConstraints)
    {
      foreignRelation = db_getRelation(elem.refTable);
      
      if (foreignRelation == null) {
        return new DBMessage(MsgType.ReferenceTableExistenceError);
      }

      // Check the count of reference column
      int forKeySize = elem.foreign.size();
      int refKeySize = elem.refKeys.size();
      if (forKeySize != refKeySize) {
        return new DBMessage(MsgType.ReferenceTypeError);
      }
      
      msg = Relation.referenceCheck(relation, foreignRelation, elem);
      
      if (msg != null) {
        return msg;
      }     }        ArrayList<String> foreignKeys = relation.getForeignKeys();
    for (String fKey : foreignKeys)
    {
      String refTable = relation.getRefTable(fKey);
      db_addReferenceList(refTable, table);
    }
    
    db_insertTableList(table);
    db_createTable(table, relation);
    return new DBMessage(MsgType.CreateTableSuccess, table);
  }

  // Query process for drop table  public static DBMessage query_dropTable(String table)
  {
    Relation relation = db_getRelation(table);
    
    // Search if table exists    if (relation == null) {       return new DBMessage(MsgType.NoSuchTable);
    }
    
    // Check if referenced by other table    if (relation.getRefCount() > 0) {      return new DBMessage(MsgType.DropReferencedTableError, table);
    }

    ArrayList < String > foreignKeys = relation.getForeignKeys();
    for (String fKey : foreignKeys)
    {
      String refTable = relation.getRefTable(fKey);
      db_delReferenceList(refTable, table);
    }
    
    db_removeTableList(table);
    db_byte_delete(table);
    return new DBMessage(MsgType.DropSuccess, table);
  }

  // Query process for desc operation  public static DBMessage query_desc(String table)
  {
    Relation relation = db_getRelation(table);

    // Check if there is no such table    if (relation == null) {      return new DBMessage(MsgType.NoSuchTable);
    }

    System.out.println(relation.describe());
    
    return new DBMessage();
  }

  // Query process for show tables  public static DBMessage query_showTables()
  {
    ArrayList < String > tableList = (ArrayList < String >) db_objDeserialize(db_byte_search(DB_TABLE_LIST));
    // If there is no table in database    if (tableList.size() == 0)
    {
      // Error Message ShowTablesNoTable      return new DBMessage(MsgType.ShowTablesNoTable);
    }
    System.out.println("----------------");
    for (String tableName : tableList)
    {
      System.out.println(tableName);
    }
    System.out.println("----------------");
    return new DBMessage();
  }

  // Query process for insert table  public static DBMessage query_insert(String table, Parse_InsertValue insertVal)
  {
    Relation relation = db_getRelation(table);
    DBMessage msg;
    
    if (relation == null) {
      return new DBMessage(MsgType.NoSuchTable);
    }

    ArrayList<ValueCompare> vcList = new ArrayList<ValueCompare>();
    msg = relation.insertConstraintsCheck(insertVal, vcList);

    if (msg != null) {
      return msg;
    }

    ArrayList<String> referingTableList = relation.getReferingTableList();
    
    for (String refTableName : referingTableList) {
      ArrayList<String> refColList = relation.getTableReferingColumns(refTableName);
      ArrayList<ValueCompare> filteredVC = ValueCompare.vcColumnFilter(vcList, refColList);

      ArrayList<ArrayList<Value>> refResult = new ArrayList<ArrayList<Value>>();
      Relation refRelation = db_getRelation(refTableName);

      msg = refRelation.select(filteredVC, refResult);
      if (msg != null) {
        // TODO DEBUG This code should not be executed
        System.out.println("This should not be displayed. Insert Primary Search Error");
      }

      if (refResult.size() != 1) {
        return new DBMessage(MsgType.InsertReferentialIntegrityError);
      }
    }

    relation.insertRecord(vcList);
    db_byte_replace(table, db_objSerialize(relation));    return new DBMessage(MsgType.InsertResult);
  }

  // Query process for delete table  public static DBMessage query_delete(String table, BooleanExpression where)
  {
    DBMessage msg = new DBMessage(MsgType.NotImplemented);
    // TODO    return msg;
  }

  // Query process for select table  public static DBMessage query_select(Parse_Select input)
  {
    // Delete
    DBMessage msg = new DBMessage(MsgType.NotImplemented);

	msg = db_selectValidCheck(input);
	if (msg != null) {
	  return msg;
	}

	Relation cartesian = db_selectJoin(input.tables);
	ArrayList<ArrayList<Value>> searchResult = null;
    
	try {
      searchResult = input.boolPredicate.filter(cartesian);
	}
	catch (MyException e) {
	  return e.getDBMessage();
	}

    ArrayList<Integer> indexList = new ArrayList<Integer>();
    ArrayList<ArrayList<Value>> selectedResult = db_columnSelect(input.selected, indexList, cartesian, searchResult);
    db_printResult(input.selected, indexList, cartesian, selectedResult);
        return null;
  }

  // Physically insert new table in key-value pair  private static void db_createTable(String table, Relation rel)
  {
    db_byte_insert(table, db_objSerialize(rel));
  }

  // Add to table list  private static void db_insertTableList(String table)
  {
    ArrayList < String > tableList = (ArrayList < String >) db_objDeserialize(db_byte_search(DB_TABLE_LIST));
    if (tableList == null) return;
    if (tableList.contains(table)) return;
    tableList.add(table);
    db_byte_replace(DB_TABLE_LIST, db_objSerialize(tableList));
  }

  // Delete from table list  private static void db_removeTableList(String table)
  {
    ArrayList < String > tableList = (ArrayList < String >) db_objDeserialize(db_byte_search(DB_TABLE_LIST));
    if (tableList == null) return;
    if (!tableList.contains(table)) return;
    tableList.remove(table);
    db_byte_replace(DB_TABLE_LIST, db_objSerialize(tableList));
  }

  // Check if table name exists  private static boolean db_checkTableExist(String table)
  {
    ArrayList < String > tableList = (ArrayList < String >) db_objDeserialize(db_byte_search(DB_TABLE_LIST));
    return tableList.contains(table);
  }

  // Get Relation  private static Relation db_getRelation(String table)
  {
    byte [] data = db_byte_search(table);
    Relation rel = null;
    if (data != null)
    {
      rel = (Relation) db_objDeserialize(data);
    }
    return rel;
  }

  // Add to reference list  private static void db_addReferenceList(String target, String curr)
  {
    Relation targetRel = db_getRelation(target);
    if (targetRel == null) return;
    targetRel.addReferedTableList(curr);
    db_byte_replace(target, db_objSerialize(targetRel));
  }

  // Delete from reference list  private static void db_delReferenceList(String target, String curr)
  {
    Relation targetRel = db_getRelation(target);
    if (targetRel == null) return;
    targetRel.delReferedTableList(curr);
    db_byte_replace(target, db_objSerialize(targetRel));
  }

  private static DBMessage db_selectValidCheck(Parse_Select input) {
    DBMessage msg = null;

    for (Rename r : input.tables) {
      if (!db_checkTableExist(r.tableName)) {
        return new DBMessage(MsgType.SelectTableExistenceError, r.tableName);
      }
    }
    
    msg = input.validCheck();
    if(msg != null) {
      return msg;
    }

    return msg;
  }

  private static Relation db_selectJoin(ArrayList<Rename> tables) {
    Relation result = new Relation("--result");
    Relation rtemp;

    for (Rename r : tables) {
      rtemp = db_getRelation(r.tableName);
      result = Relation.join(result, null, rtemp, r.newName);
    }
    
    return result;
  }

  private static ArrayList<ArrayList<Value>> db_columnSelect(ArrayList<Rename> selectList, ArrayList<Integer> indexList, Relation r, ArrayList<ArrayList<Value>> searchResult) {
    ArrayList<Attribute> schema = r.getSchema();
    int schemaSize = schema.size();

    if (selectList == null) {
      for (int i = 0; i < schemaSize; i++) {
        indexList.add(i);
      }
      return searchResult;
    }
    
    ArrayList<ArrayList<Value>> result = new ArrayList<ArrayList<Value>>();

    String searchPattern;
    for (Rename rename : selectList) {
      searchPattern = (rename.tableName==null?"":rename.tableName) + "." + rename.columnName;
      for (int idx = 0; idx < schema.size(); idx++) {
        Attribute attr = schema.get(idx); 
        if (Relation.lastMatch(attr.getName(), searchPattern) >= 0) {
          indexList.add(idx);
          break;
        }
      }
    }

    ArrayList<Value> entity;
    for (ArrayList<Value> rec : searchResult) {
      entity = new ArrayList<Value>();
      for (int idx : indexList) {
        entity.add(rec.get(idx));
      }
      result.add(entity);
    }
    
    return result;
  }
  
  private static void db_printResult(ArrayList<Rename> selectList, ArrayList<Integer> idxList, Relation r, ArrayList<ArrayList<Value>> searchResult) {
    ArrayList<String> titleList = new ArrayList<String>();
    ArrayList<Attribute> schema = r.getSchema();

    Integer[] length = new Integer[idxList.size()];
    
    for (int i = 0; i < idxList.size(); i++) {
      length[i] = schema.get(idxList.get(i)).getDefaultLength();
    }
    
    if (selectList == null) {
      for (int i = 0; i < idxList.size(); i++) {
        titleList.add(schema.get(i).getName());
        length[i] = db_max(length[i], titleList.get(i).length());
      }
    }
    else {
      for (int i = 0; i < selectList.size(); i++) {
        Rename rename = selectList.get(i);
        if (rename.newName != null) {
          titleList.add(rename.newName);
        }
        else if (rename.tableName != null) {
          titleList.add(rename.tableName + "." + rename.columnName);
        }
        else {
          titleList.add(rename.columnName);
        }
        length[i] = db_max(length[i], titleList.get(i).length());
      }
    }
    
    int resultSize = searchResult.size();
    int columnSize = titleList.size();
    
    for (int i = 0; i < columnSize; i++) {
      for (int j = 0; j < resultSize; j++) {
        length[i] = db_max(length[i], searchResult.get(j).get(i).getLength());
      }
    }

    db_realPrint(titleList, length, searchResult);
  }

  private static void db_realPrint(ArrayList<String> title, Integer[] length, ArrayList<ArrayList<Value>> searchResult) {
    int columnNum = title.size();
    ArrayList<String> format = new ArrayList<String>();

    for (int i = 0; i < columnNum; i++) {
      String f = String.format(" %%-%ds ", length[i]);
      format.add(f);
    }

    String border = "+";
    for (int i = 0; i < columnNum; i++) {
      for (int j = 0; j < length[i] + 2; j++) {
        border = border + "-";
      }
      border = border + "+";
    }

    System.out.println(border);
    
    // Column Names
    System.out.print("|");
    for (int i = 0; i < columnNum; i++) {
      System.out.printf(format.get(i), title.get(i));
      System.out.print("|");
    }
    System.out.println();

    System.out.println(border);

    // Data
    
    for (int j = 0; j < searchResult.size(); j++) {
      System.out.print("|");
      for (int i = 0; i < columnNum; i++) {
        System.out.printf(format.get(i), searchResult.get(j).get(i));
        System.out.print("|");
      }
      System.out.println();
    }

    System.out.println(border);
  }

  // Insert byte data in key-value pair  private static void db_byte_insert(String key, byte [] data)
  {
    Cursor cursor = null;
    try
    {
      cursor = myDatabase.openCursor(null, null);
      DatabaseEntry db_key = new DatabaseEntry(key.getBytes("UTF-8"));
      DatabaseEntry db_data = new DatabaseEntry(data);
      cursor.put(db_key, db_data);
    }
    catch (Exception e)
    {
      e.printStackTrace();
    }
    cursor.close();
  }

  // Get byte data from key  private static byte [] db_byte_search(String key)
  {
    Cursor cursor = null;
    byte [] value = null;
    try
    {
      cursor = myDatabase.openCursor(null, null);
      DatabaseEntry db_key = new DatabaseEntry(key.getBytes("UTF-8"));
      DatabaseEntry db_value = new DatabaseEntry();
      if (cursor.getSearchKey(db_key, db_value, LockMode.DEFAULT) == OperationStatus.SUCCESS)
      {
        value = db_value.getData();
      }
    }
    catch (Exception e)
    {
      e.printStackTrace();
    }
    cursor.close();
    return value;
  }

  // Replace value with new byteData  private static void db_byte_replace(String key, byte [] newData)
  {
    Cursor cursor = null;
    try
    {
      cursor = myDatabase.openCursor(null, null);
      DatabaseEntry db_key = new DatabaseEntry(key.getBytes("UTF-8"));
      DatabaseEntry db_value = new DatabaseEntry();
      DatabaseEntry new_value;
      if (cursor.getSearchKey(db_key, db_value, LockMode.DEFAULT) == OperationStatus.SUCCESS)
      {
        new_value = new DatabaseEntry(newData);
        cursor.putCurrent(new_value);
      }
    }
    catch (Exception e)
    {
      e.printStackTrace();
    }
    cursor.close();
  }

  // Delete key-value pair  private static void db_byte_delete(String key)
  {
    Cursor cursor = null;
    try
    {
      cursor = myDatabase.openCursor(null, null);
      DatabaseEntry db_key = new DatabaseEntry(key.getBytes("UTF-8"));
      DatabaseEntry db_value = new DatabaseEntry();
      if (cursor.getSearchKey(db_key, db_value, LockMode.DEFAULT) == OperationStatus.SUCCESS)
      {
        cursor.delete();
      }
    }
    catch (Exception e)
    {
      e.printStackTrace();
    }
    cursor.close();
  }

  private static int db_max(int a, int b) {
    return a > b ? a : b;
  }
}

PARSER_END(SQLParser)

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
} // Default Skip Token
TOKEN : /* Keywords */
{
  < EXIT : "exit" >
| < INT : "int" >
| < CHAR : "char" >
| < DATE : "date" >
| < CREATE_TABLE : "create table" >
| < PRIMARY_KEY : "primary key" >
| < FOREIGN_KEY : "foreign key" >
| < REFERENCES : "references" >
| < DROP_TABLE : "drop table" >
| < DESC : "desc" >
| < SHOW_TABLES : "show tables" >
| < SELECT : "select" >
| < AS : "as" >
| < FROM : "from" >
| < WHERE : "where" >
| < OR : "or" >
| < AND : "and" >
| < NOT : "not" >
| < IS : "is" >
| < INSERT_INTO : "insert into" >
| < VALUES : "values" >
| < NULL : "null" >
| < DELETE_FROM : "delete from" >
}

/* Change Lexical State when QUOTE appeared */
TOKEN :
{
  < QUOTE : "\'" > : IN_QUOTE
}

< IN_QUOTE >
SKIP :
{
  "\r"
| "\t"
| "\n"
}	 // Newly defined skip token
< IN_QUOTE >
TOKEN :
{
  < INQ_QUOTE : "\'" > : DEFAULT
| < INQ_SPACE : " " >
| < NON_QUOTE_SPECIAL_CHARACTERS : ~[ "\'", "\"", "0"-"9", "A"-"Z", "a"-"z" ] >
| < NON_QUOTE_CHARACTER :
    < DIGIT >
  | < ALPHABET >
  | < NON_QUOTE_SPECIAL_CHARACTERS >
  | < INQ_SPACE > >
}

TOKEN : /* Tokens */
{
  < SEMICOLON : ";" >
| < LEFT_PAREN : "(" >
| < RIGHT_PAREN : ")" >
| < COMMA : "," >
| < UNDERSCORE : "_" >
| < INT_VALUE : (< SIGN >)? (< DIGIT >)+ >
| < SIGN :
    "+"
  | "-" >
| < DIGIT : [ "0"-"9" ] >
| < LEGAL_IDENTIFIER :
    < ALPHABET >
    (
      < ALPHABET >
    | < UNDERSCORE >
    )* >
| < ALPHABET : [ "a"-"z", "A"-"Z" ] >
| < ASTERISK : "*" >
| < PERIOD : "." >
| < COMP_OP :
    "<"
  | ">"
  | "="
  | ">="
  | "<="
  | "!=" >
| < CHAR_STRING : < QUOTE > (< NON_QUOTE_CHARACTER >)* < QUOTE > >
| < NNNN : < DIGIT > < DIGIT > < DIGIT > < DIGIT > >
| < NN : < DIGIT > < DIGIT > >
| < DATE_VALUE : < NNNN > "-" < NN > "-" < NN > >
}

/* Parse Command */
void command() :
{}
{
  queryList()
|
  (
    < EXIT > 
    < SEMICOLON >
    {
      db_close();
      System.exit(0);
    }
  )
}

void queryList() :
{
  DBMessage msg;
}
{
  (
    msg = query()
    {
      printMessage(msg);
    }
  )+
}

DBMessage query() :
{
  DBMessage msg;
}
{
  (
    msg = createTableQuery()
  | msg = dropTableQuery()
  | msg = descQuery()
  | msg = selectQuery()
  | msg = insertQuery()
  | msg = deleteQuery()
  | msg = showTablesQuery()
  )
  { return msg; }
}

/* CREATE TABLE QUREY */
DBMessage createTableQuery() :
{
  DBMessage msg;
  String table;
  ArrayList < Parse_TableElement > schema;
}
{
  < CREATE_TABLE > 
  table = tableName() 
  schema = tableElementList() 
  < SEMICOLON >
  {
    msg = query_createTable(table, schema);
    return msg;
  }
}

ArrayList < Parse_TableElement > tableElementList() :
{
  ArrayList < Parse_TableElement > tableElementList = new ArrayList < Parse_TableElement > ();
  Parse_TableElement element;
}
{
  < LEFT_PAREN > 
  element = tableElement()
  {
    tableElementList.add(element);
  }
  (
    < COMMA > 
    element = tableElement()
    {
      tableElementList.add(element);
    }
  )*
  < RIGHT_PAREN >
  {
    return tableElementList;
  }
}

Parse_TableElement tableElement() :
{
  Parse_TableElement elem;
}
{
  (
    elem = columnDefinition()
  | elem = tableConstraintDefinition()
  )
  {
    return elem;
  }
}

Parse_TableElement columnDefinition() :
{
  Parse_TableElement elem;
  String colName;
  boolean nullable = true;
}
{
  colName = columnName() 
  elem = dataType() 
  (
  < NOT > 
  < NULL >
  {
    nullable = false;
  }
  )?
  {
    elem.columnName = colName;
    elem.nullable = nullable;
    return elem;
  }
}

Parse_TableElement tableConstraintDefinition() :
{
  Parse_TableElement elem;
}
{
  (
    elem = primaryKeyConstraint()
  | elem = referentialConstraint()
  )
  {
    return elem;
  }
}

Parse_TableElement primaryKeyConstraint() :
{
  ArrayList < String > colList;
}
{
  < PRIMARY_KEY > 
  colList = columnNameList()
  {
    return new Parse_TableElement(colList);
  }
}

Parse_TableElement referentialConstraint() :
{
  String table;
  ArrayList < String > foreignColList;
  ArrayList < String > refColList;
}
{
  < FOREIGN_KEY > 
  foreignColList = columnNameList() 
  < REFERENCES > 
  table = tableName() 
  refColList = columnNameList()
  {
    return new Parse_TableElement(foreignColList, table, refColList);
  }
}

ArrayList < String > columnNameList() :
{
  ArrayList < String > colList = new ArrayList < String > ();
  String elem;
}
{
  < LEFT_PAREN > 
  elem = columnName()
  {
    colList.add(elem);
  }
  (
    < COMMA > 
    elem = columnName()
    {
      colList.add(elem);
    }
  )*
  < RIGHT_PAREN >
  {
    return colList;
  }
}

Parse_TableElement dataType() :
{
  Token intval;
}
{
  < INT >
  {
    return new Parse_TableElement(DataType.TYPE_INT);
  }
|
  (
    < CHAR > 
    < LEFT_PAREN > 
    intval = < INT_VALUE > 
    < RIGHT_PAREN >
    {
      return new Parse_TableElement(DataType.TYPE_CHAR, Integer.parseInt(intval.image));
    }
  )
| < DATE >
  {
    return new Parse_TableElement(DataType.TYPE_DATE);
  }
}

String tableName() :
{
  Token id;
}
{
  id = < LEGAL_IDENTIFIER >
  {
    return id.image.toLowerCase();
  }
}

String columnName() :
{
  Token id;
}
{
  id = < LEGAL_IDENTIFIER >
  {
    return id.image.toLowerCase();
  }
}

/* DROP TABLE QUERY */
DBMessage dropTableQuery() :
{
  DBMessage msg;
  String table;
}
{
  < DROP_TABLE > 
  table = tableName() 
  < SEMICOLON >
  {
    msg = query_dropTable(table);
    return msg;
  }
}

/* DESC QUERY */
DBMessage descQuery() :
{
  DBMessage msg;
  String table;
}
{
  < DESC > 
  table = tableName() 
  < SEMICOLON >
  {
    msg = query_desc(table);
    return msg;
  }
}

/* SHOW TABLES QUERY */
DBMessage showTablesQuery() :
{
  DBMessage msg;
}
{
  < SHOW_TABLES > 
  < SEMICOLON >
  {
    msg = query_showTables();
    return msg;
  }
}

/* SELECT QUERY */
DBMessage selectQuery() :
{
  DBMessage msg;
  ArrayList<Rename> selected, tables;
  BooleanExpression boolExpr = null;
}
{
  < SELECT >
  selected = selectList()
  tables = fromClause()
  (
    boolExpr = whereClause()
  )?
  < SEMICOLON >
  {
    msg = query_select(new Parse_Select(selected, tables, boolExpr));
    return msg;
  }
}

ArrayList<Rename> selectList() :
{
  ArrayList<Rename> selected = new ArrayList<Rename>();
  Rename r;
}
{
  < ASTERISK >
  { return null; }
|
  (
    r = selectedColumn()
    { selected.add(r); }
    (
      < COMMA > 
      r = selectedColumn()
      { selected.add(r); }
    )*
  )
  { return selected; }
}

Rename selectedColumn() :
{
  String tName = null;
  String cName = null;
  String newName = null;
}
{
  (
    /*   * LOOKAHEAD : Warning Suppression : Choice Conflict   *   * Parser should check 2 token before entering '?' statement   * because both tableName() and columnName() are < LEGAL_IDENTIFIER >   */
    LOOKAHEAD(tableName() < PERIOD >)
    tName = tableName() 
    < PERIOD >
  )?
  cName = columnName()
  (
    < AS > 
    newName = columnName()
  )?
  { return new Rename(tName, cName, newName); }
}

ArrayList<Rename> fromClause() :
{ ArrayList<Rename> tables; }
{
  < FROM > 
  tables = tableReferenceList()
  { return tables; }
}

ArrayList<Rename> tableReferenceList() :
{
  ArrayList<Rename> tables = new ArrayList<Rename>();
  Rename r;
}
{
  r = referedTable()
  { tables.add(r); }
  (
    < COMMA > 
    r = referedTable()
    { tables.add(r); }
  )*
  { return tables; }
}

Rename referedTable() :
{
  String tName = null;
  String newName = null;
}
{
  tName = tableName()
  (
    < AS > 
    newName = tableName()
  )?
  { return new Rename(tName, null, newName); }
}

BooleanExpression whereClause() :
{ BooleanNode b; }
{
  < WHERE > 
  b = booleanValueExpression()
  { return new BooleanExpression(b); }
}

BooleanNode booleanValueExpression() :
{
  BooleanNode b1, b2;
}
{
  b1 = booleanTerm()
  (
    < OR > 
    b2 = booleanTerm()
    { b1 = new BooleanNode('|', b1, b2); }
  )*
  { return b1; }
}

BooleanNode booleanTerm() :
{
  BooleanNode b1, b2;
}
{
  b1 = booleanFactor()
  (
    < AND > 
    b2 = booleanFactor()
    { b1 = new BooleanNode('&', b1, b2); }
  )*
  { return b1; }
}

BooleanNode booleanFactor() :
{
  boolean isNot = false;
  BooleanNode b;
}
{
  (
    < NOT >
    { isNot = true; }
  )?
  b = booleanTest()
  {
	if (isNot) {
	  return new BooleanNode('~', b);
	}
	else {
	  return b;
	}
  }
}

BooleanNode booleanTest() :
{
  Predicate p;
  BooleanNode b;
}
{
  p = predicate()
  { return new BooleanNode(p); }
| b = parenthesizedBooleanNode()
  { return b; }
}

BooleanNode parenthesizedBooleanNode() :
{ BooleanNode b; }
{
  < LEFT_PAREN > 
  b = booleanValueExpression() 
  < RIGHT_PAREN >
  { return b; }
}

Predicate predicate() :
{ Predicate p; }
{

  (
   /*
    * LOOKAHEAD : Warning Suppression : Conflict involving two expansions
    *
    * Parser should check compOperand() and < COMP_OP >
    * because both comparisonPredicate() and nullPredicate() can be start with < LEGAL_IDENTIFIER >
    */
    LOOKAHEAD(compOperand() < COMP_OP >)
    p = comparisonPredicate()
  | p = nullPredicate()
  )
  { return p; }
}

Predicate comparisonPredicate() :
{
  Token t;
  ValueCompare vc1, vc2;
}
{
  vc1 = compOperand() 
  t = < COMP_OP >
  vc2 = compOperand()
  {
    return Predicate.generate(Comparator.convert(t.image), vc1, vc2);
  }
}

ValueCompare compOperand() :
{
  Value v;
  String t = null, c;
}
{
  v = comparableValue()
  { return new ValueCompare(v); }
|
  (
    (
     /*      * LOOKAHEAD : Warning Suppression : Choice Conflict      *      * Parser should check 2 token before entering '?' statement      * because both tableName() and columnName() are < LEGAL_IDENTIFIER >      */
      LOOKAHEAD(tableName() < PERIOD >)
      t = tableName() 
      < PERIOD >
    )?
    c = columnName()
    {  return new ValueCompare(t, c); }
  )
}

Value comparableValue() :
{
  Token id;
}
{
  id = < INT_VALUE >
  { return new Value(Integer.parseInt(id.image)); }
| id = < CHAR_STRING >
  { return new Value(id.image.substring(1, id.image.length()-1)); }
| id = < DATE_VALUE >
  { return new Value(new Date(id.image)); }
}

Predicate nullPredicate() :
{
  String t = null, c;
  Comparator op;
}
{
  (
   /*    * LOOKAHEAD : Warning Suppression : Choice Conflict    *    * Parser should check 2 token before entering '?' statement    * because both tableName() and columnName() are < LEGAL_IDENTIFIER >    */
    LOOKAHEAD(tableName() < PERIOD >)
    t = tableName() 
    < PERIOD >
  )?
  c = columnName() 
  op = nullOperation()
  { return new Predicate(op, t, c); }
}

Comparator nullOperation() :
{ boolean isNull = true; }
{
  < IS > 
  (
    < NOT >
    { isNull = false; }
  )? 
  < NULL >
  { return Comparator.convert(isNull); }
}

/* INSERT QUERY */
DBMessage insertQuery() :
{
  DBMessage msg;
  String table;
  Parse_InsertValue insertVal;
}
{
  < INSERT_INTO > 
  table = tableName() 
  insertVal = insertColumnsAndSource() 
  < SEMICOLON >
  {
    msg = query_insert(table, insertVal);
    return msg;
  }
}

Parse_InsertValue insertColumnsAndSource() :
{
  ArrayList < String > colList = null;
  ArrayList < Value > valList = null;
}
{
  (
    colList = columnNameList()
  )?
  valList = valueList()
  { return new Parse_InsertValue(colList, valList); }
}

ArrayList < Value > valueList() :
{
  ArrayList < Value > valList = new ArrayList<Value>();
  Value val;
}
{
  < VALUES > 
  < LEFT_PAREN > 
  val = value()
  {
    if (val == null) {
      valList.add(new Value());
    }
    else {
      valList.add(val);
    }
  }    
  (
    < COMMA > 
    val = value()
    {
      if (val == null) {
        valList.add(new Value());
      }
      else {
        valList.add(val);
      }
    }
  )*
  < RIGHT_PAREN >
  { return valList; }
}

Value value() :
{
  Value val;
}
{
  < NULL >
  { return null; }
| val = comparableValue()
  { return val; }
}

/* DELETE QUERY */
DBMessage deleteQuery() :
{
  DBMessage msg;
  String t;
  BooleanExpression b = null;
}
{
  < DELETE_FROM > 
  t = tableName()
  (
    b = whereClause()
  )?
  < SEMICOLON >
  {
    msg = query_delete(t, b);
    return msg;
  }
}
